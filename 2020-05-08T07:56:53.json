{"timestamp": "2020-05-08T09:04:03", "body": "## Scheme v. Python\n\n(I promised myself to stick to zettlekasten kind of note (small and\natomic), but here is a topic I have been thinking about for a while\nand I think I have enough matter to make a full post.)\n\nI have been practicing Scheme for 5 years and Python for more than 10\nyears.  I know other programming languages but Python and Scheme are\nthe two I am the most familiar with and the more invested in.\n\nIn this note, I will try to compare Scheme versus Python from high\nlevel point of view of their respective ecosystems to a low level\npoint of view of nitty gritty good old lines of code.\n\n### History\n\nScheme grew in academical circles and until recently it was the\nprimary teaching material for computer science programming. The touted\nbook is known as\n[SICP](https://mitpress.mit.edu/sites/default/files/sicp/index.html).\nI have that book, I read it from time to time, but never completed any\nexercices.  There is somewhat a cult around that book until the point\nwhere it became a\n[meme](https://knowyourmeme.com/forums/meme-research/topics/47038-structure-and-interpretation-of-computer-programs-hugeass-image-dump-for-evidence). And\nthe book was adapted to JavaScript.\n\nMIT university switched from Scheme to Python around 2009. The\nrationale can be *grossly* summarized as nowadays coders do not need\nto know all the stuff SICP teach, or try to teach.\n\nThis happened a little before or at the same time Machine Learning\nfrenzy happened, at which point data science was a thing.\n\nEven if Scheme was teached decades in various universities, it has\nlittle or not industrial footprint.  That is, there is not a lot of\nusers of Scheme.\n\nThis partly due to AI winter around 1980, that match with LISP winter\nwhere LISP programming language like Scheme, even if very powerful and\nhigh level, were slow.\n\n### Standards and Implementations\n\nThere is at least seven iterations over the definitions of Scheme\nprogramming language. The latest is [R7RS](https://small.r7rs.org/).\nThere is (too many) implementations, among the most notable there is\nRacket.  There is no reference implementation, but chibi scheme has\nlot of traction toward that. Until recently the standard was put\ntogether by a group of experts with a unanimity vote. Nowadays the\nprocess is open to anyone.\n\nPython is at verion 3.8. It used to be supervised by a BDFL, but\nnowadays it is created by a group of core developers.  The reference\nimplementation is CPython, a bytecode interpreter, the other popular\nimplementations includes PyPy a Just-In-Time Compiler Virtual Machine.\nThere is also micropython that targets small hardware.\n\nThe main differences between both programming languages are as follow:\n\n- A democractic standard versus core developer group\n- A lot of implementations versus a few implementations\n\nOn microbenchmarks, Racket is faster than PyPy and CPython. And Racket\nis not the fastest Scheme.\n\nOne might say, speed does not matter (except when it does).\n\nScheme open-source offering is fragmented, there is many\nimplementations, each of which used to have different module system,\nwhich leads to maybe a lot of Scheme libraries, but since libraries\nwere incompatible between Scheme implementation, you would end missing\na few *things*.\n\nPython open-source offering is more comparable to JavaScript.  That is\nthere is a lot of libraries available in the wild, and since most users\nuse CPython, there is no problem of compatibility.\n\n### Language features\n\nBoth Python and Scheme are LISP 1, that is they use the same\nenvironment (or namespace) for variables and functions (that are called\nprocedures in Scheme).  I never practiced LISP 2 like Common Lisp or\nelisp, so I can not really tell whether one is better than the other.\n\nScheme is lexically scoped, whereas Python is function-scoped. You do\nnot see the difference until you use Python's `nonlocal` or `global`.\nThe difference is minimal, the only thing that is surprising about\nPython's `nonlocal` is the fact that it is an exception rule. That is,\nthe behavior is to bind a new variable possibly shadowing the\npreviously defined variable with the same name, exept when you do not\nwant to shadow.  Usually, in programming it is easier to think in\nterms of \"what you want\" instead of \"what you do not want\" because the\ngeneral semantic of the negation is unbound (unlike boolean `not`).\n\nPython has loads of features, and most structural change to the\nlanguage require a change in the implementation. Nowadays, the most\nvisible instance of that problem is the `async` and `await` keywords.\n\nIn general, the approach taken by Scheme is to have powerful enough\nprimitives to make it possible to adapt to most, if not any,\nsituations.  To compare to Python `async` and `await`, the approach\ntaken with Scheme to solve the same problem to have sequential\nasynchronous code, does not require a change in the compiler or\nvirtual machine implementation.  Instead, Scheme implementation\nprovide a procedure that allows to customize the control flow. They\noptimized for the general (or generic) case.  I took as example\nsequential asynchronous code, but that is the same for class and\nmeta-class based code. All those, with Scheme can be defined as\nlibraries.\n", "links": []}